test {
	name 'effects in mutable init'
	case {
		[Mutable] ([console] hello)
	}
	expect "
		hello
		
	`"
}

test {
	name 'effects in mutable init, init function'
	case {
		[Mutable] ([console] 1) ([console] 2)
	}
	expect "
		1
		2
		
	`"
}

test {
	name 'create mutable and use value'
	case {
		[Mutable] hello set get {
			[console] get
		}
	}
	expect "
		hello
		
	`"
}

test {
	name 'create mutable and use value twice'
	case {
		[Mutable] hello set get {
			[console] get
			([console] get)
		}
	}
	expect "
		hello
		hello
		
	`"
}

test {
	name 'create mutable one and print static inverted'
	case {
		[Mutable] hello set get {
			[console] world
			([console] get)
		}
	}
	expect "
		world
		hello
		
	`"
}

test {
	name 'create mutable one and print static'
	case {
		[Mutable] hello set get {
			[console] get
			([console] world)
		}
	}
	expect "
		hello
		world
		
	`"
}

test {
	name 'create mutable reset and then use'
	case {
		[Mutable] hello set get {
			[root ``] (set world) ([console] get)
		}
	}
	expect "
		world
		
	`"
}

test {
	name 'create mutable use reset use'
	case {
		[Mutable] hello set get {
			[root ``] (set world) ([console] get)
			([root ``] (set !!) ([console] get))
		}
		[Mutable] hello ([root Function] set {[root Function] get {
			[root ``] (set world) ([console] (get void))
			([root ``] (set !!) ([console] (get void)))
		}})
	}
	expect "
		world
		!!
		
	`"
}

test {
	name "wierd thing that didn't work once`"
	case {
		[Mutable] hello set get {
			[root ``] (
				[root ``] (lol lol) ([console] world)
				([root ``] (set !!) ([console] !!))
			) ([console] !!)
		}
	}
	expect "
		world
		!!
		!!
		
	`"
}

test {
	name 'create mutable use reset use twice'
	case {
		[Mutable] hello set get {
			[root ``] (
				[root ``] (set world) ([console] get)
				([root ``] (set !!) ([console] get))
			) ([console] get)
		}
	}
	expect "
		world
		!!
		!!
		
	`"
}

test {
	name 'create two mutable and use simultaneously'
	case {
		[Mutable] [console] set get {
			[Mutable] hello set1 get1 {
				get get1
			}
		}
	}
	expect "
		hello
		
	`"
}

test {
	name 'create two linearly dependant mutable instances'
	case {
		[Mutable] hello set get {
			[Mutable] get set1 get1 {
				[console] get1
			}
		}
	}
	expect "
		hello
		
	`"
}

test {
	name 'two concurrent mutable instances'
	case {
		[Mutable] hello set1 get1 {
			[Mutable] world set2 get2 {
				([console] get1) ([console] get2)
			}
		}
	}
	expect "
		hello
		world
		
	`"
}

test {
	name 'two concurrent mutable instances, mutate one'
	case {
		[Mutable] hello set1 get1 {
			[Mutable] world set2 get2 {
				[root ``] (set2 hello) (([console] get1) ([console] get2))
			}
		}
	}
	expect "
		hello
		hello
		
	`"
}

test {
	name 'two concurrent mutable instances, mutate both'
	case {
		[Mutable] hello set1 get1 {
			[Mutable] world set2 get2 {
				[root ``] ((set2 hello) (set1 world)) (([console] get1) ([console] get2))
			}
		}
	}
	expect "
		world
		hello
		
	`"
}

test {
	name 'create mutable use reset use common indirection'
	case {
		[Mutable] hello set get {
			[root Function] print {
				[root ``] (set world) (print void)
				([root ``] (set !!) (print void))
			} ([root Function] void {
				[console] get
			})
		}
	}
	expect "
		world
		!!
		
	`"
}

test {
	name 'mutation common initializer'
	case {
		[root Function] createMutable {
			[console] (createMutable void get)
		} ([root Function] void {
			[Mutable] hello mSet mGet {
				[root Function] env {
					[root Scope] ([compare] env get {mGet} {
						[root Scope] ([compare] env set {
							mSet
						} {mGet env})
					})
				}
			}
		})
	}
	expect "
		hello
		
	`"
}

test {
	name 'mutation common initializer use twice'
	case {
		[root Function] createMutable {
			[root Function] a {
				[root Function] b {
					[root ``] ([console] (a get)) ([console] (b get))
				} (createMutable void)
			} (createMutable void)
		} ([root Function] void {
			[Mutable] hello mSet mGet {
				[root Function] env {
					[root Scope] ([compare] env get {mGet} {
						[root Scope] ([compare] env set {
							mSet
						} {mGet env})
					})
				}
			}
		})
	}
	expect "
		hello
		hello
		
	`"
}

test {
	name 'mutation common initializer use twice set once'
	case {
		[root Function] createMutable {
			[root Function] a {
				[root Function] b {
					[root ``] (a set world) ([root ``] ([console] (a get)) ([console] (b get)))
				} (createMutable void)
			} (createMutable void)
		} ([root Function] void {
			[Mutable] hello mSet mGet {
				[root Function] env {
					[root Scope] ([compare] env get {mGet} {
						[root Scope] ([compare] env set {
							mSet
						} {mGet env})
					})
				}
			}
		})
	}
	expect "
		world
		hello
		
	`"
}

test {
	name 'mutation common initializer use twice set once reversed'
	case {
		[root Function] createMutable {
			[root Function] a {
				[root Function] b {
					[root ``] (b set world) ([root ``] ([console] (a get)) ([console] (b get)))
				} (createMutable void)
			} (createMutable void)
		} ([root Function] void {
			[Mutable] hello mSet mGet {
				[root Function] env {
					[root Scope] ([compare] env get {mGet} {
						[root Scope] ([compare] env set {
							mSet
						} {mGet env})
					})
				}
			}
		})
	}
	expect "
		hello
		world
		
	`"
}

test {
	name 'mutation behind abstraction'
	case {
		[root Function] createMutable {
			[root Function] mut {
				[console] (mut get)
			} (createMutable hello)
		} ([root Function] init {
			[Mutable] init mSet mGet {
				[root Function] env {
					[root Scope] ([compare] env get {mGet} {
						[root Scope] ([compare] env set {
							mSet
						} {mGet env})
					})
				}
			}
		})
	}
	expect "
		hello
		
	`"
}

test {
	name 'mutable behind function'
	case {
		[root Function] create {
			create set get {
				[console] get
			}
		} ([Mutable] hello)
	}
	expect "
		hello
		
	`"
}

test {
	name 'multiple behind function call'
	case {
		[root Function] create {
			create void set get {
				[console] get
			}
		} ([root Function] void {[Mutable] hello})
	}
	expect "
		hello
		
	`"
}

test {
	name 'multiple mutable behind function'
	case {
		[root Function] create {
			create void set get {
				create void set2 get2 {
					[root ``] ([console] get) ([console] get2)
				}
			}
		} ([root Function] void {[Mutable] hello})
	}
	expect "
		hello
		hello
		
	`"
}

test {
	name 'duplicated instance set one'
	case {
		[root Function] create {	
			create set get {
				create set2 get2 {
					[root ``] (set2 world) ([root ``] ([console] get) ([console] get2))
				}
			}
		} ([Mutable] hello)
	}
	expect "
		hello
		world
		
	`"
}

test {
	name 'mutible mutable behind function set one behind function'
	case {
		[root Function] create {
			create void set get {
				create void set2 get2 {
					[root ``] (set2 world) ([root ``] ([console] get) ([console] get2))
				}
			}
		} ([root Function] void {[Mutable] hello})
	}
	expect "
		hello
		world
		
	`"
}

test {
	name 'multiple mutable behind function set one reversed'
	case {
		[root Function] create {
			create void set get {
				create void set2 get2 {
					[root ``] (set world) ([root ``] ([console] get) ([console] get2))
				}
			}
		} ([root Function] void {[Mutable] hello})
	}
	expect "
		world
		hello
		
	`"
}

test {
	name 'multiple mutable behind function set one both'
	case {
		[root Function] create {
			create void set get {
				create void set2 get2 {
					[root ``] (set world)
						([root ``] (set2 yeah) (
							([root ``] ([console] get) ([console] get2))))
				}
			}
		} ([root Function] void {[Mutable] hello})
	}
	expect "
		world
		yeah
		
	`"
}

test {
	name 'mutation behind abstraction with set'
	case {
		[root Function] createMutable {
			[root Function] mut {
				[root ``] (mut set world) ([console] (mut get))
			} (createMutable hello)
		} ([root Function] init {
			[Mutable] init mSet mGet {
				[root Function] env {
					[root Scope] ([compare] env get {mGet} {
						[root Scope] ([compare] env set {
							mSet
						} {mGet env})
					})
				}
			}
		})
	}
	expect "
		world
		
	`"
}

test {
	name 'mutation behind abstraction with set use two times'
	case {
		[root Function] createMutable {
			[root Function] mut {
				[root ``] ([console] (mut get)) ([root ``] (mut set world) ([console] (mut get)))
			} (createMutable hello)
		} ([root Function] init {
			[Mutable] init mSet mGet {
				[root Function] env {
					[root Scope] ([compare] env get {mGet} {
						[root Scope] ([compare] env set {
							mSet
						} {mGet env})
					})
				}
			}
		})
	}
	expect "
		hello
		world
		
	`"
}

test {
	name 'mutable instance behind mutable'
	case {
		[Mutable] [Mutable] set get {
			get hello set1 get1 {
				[console] get1
			}
		}
	}
	expect "
		hello
		
	`"
}

test {
	name 'mutable instance behind mutable tripple'
	case {
		[Mutable] [Mutable] set get {
			get [Mutable] set1 get1 {
				get1 hello set2 get2 {
					[console] get2
				}
			}
		}
	}
	expect "
		hello
		
	`"
}

test {
	name 'mutable instance behind mutable tripple'
	case {
		[Mutable] [Mutable] set get {
			get get set1 get1 {
				get1 get1 set2 get2 {
					get2 get2 set3 get3 {
						[console] get3
					}
				}
			}
		}
	}
	expect "
		hello
		
	`"
}

test {
	name 'mutation common initializer use twice set once reversed with mutable behind other mutable'
	case {
		[Mutable] [Mutable] setMutable getMutable {
			[root Function] createMutable {
				[root Function] a {
					[root Function] b {
						[root ``] (b set world) ([root ``] ([console] (a get)) ([console] (b get)))
					} (createMutable void)
				} (createMutable void)
			} ([root Function] void {
				getMutable hello mSet mGet {
					[root Function] env {
						[root Scope] ([compare] env get {mGet} {
							[root Scope] ([compare] env set {
								mSet
							} {mGet env})
						})
					}
				}
			})
		}
	}
	expect "
		hello
		world
		
	`"
}

test {
	name 'mutable of function with effects'
	case {
		[Mutable] ([root Function] void {[console] hello}) set get {
			get void
		}
	}
	expect "
		hello
		
	`"
}

test {
	name 'mutable of function with effects with dummy set'
	case {
		[Mutable] void set get {
			[root ``] (set ([root Function] void {[console] hello}))
			(get void)
		}
	}
	expect "
		hello
		
	`"
}

test {
	name 'effects in mutable set'
	case {
		[Mutable] void set get {
			[root ``] (set ([console] hello))
			get
		}
	}
	expect "
		hello
		
	`"
}